# HotStuff-rs (version 0.2)

## Basic Types

### Block

```rust
struct Block {
    num: BlockNumber,
    hash: CryptoHash,
    justify: QuorumCertificate,
    data_hash: CryptoHash,
    data: Data,
}
```

### Quorum Certificate

```rust
struct QuorumCertificate {
    view: ViewNumber,
    block: CryptoHash,
    phase: Phase,
    signatures: SignatureSet,
}
```

### Phases 

```rust
struct Phase {
    Generic,
    Prepare,
    Precommit,
    Commit
}
```

##  Messages

```rust
enum Message {
    ProgressMessage(ProgressMessage),
    SyncMessage(SyncMessage),
}
```

### Progress Messages

```rust
enum ProgressMessage {
    Proposal(Proposal),
    Vote(Vote)
}
```

#### Proposal 

```rust
enum Proposal {
    New {
        block: Block,
        vote: Vote,
    },
    Nudge {
        justify: QuorumCertificate,
        vote: Vote,
    }
}
```

#### Vote

```rust
struct Vote {
    view: ViewNumber,
    block: CryptoHash,
    phase: Phase,
}
```

### Sync Messages

```rust
enum SyncMessage {
    SyncRequest(SyncRequest),
    SyncResponse(SyncResponse),
}
```

#### Sync Requests

```rust
struct SyncRequest {
    highest_committed_block: CryptoHash,
    limit: u32,
}
```

#### Sync Responses

```rust
struct SyncResponse {
    blocks: Vec<Block>,
    next_qc: Option<QuorumCertificate>, 
}
```

## Components

### Block Tree (Protocol State)

1. Blocks.
2. Committed App State.
3. Committed Validator Set.
4. Pending App State Changes.
5. Pending Validator Set Changes.
6. Locked View.
7. Highest Voted View
8. Highest Quorum Certificate.

### Algorithm

```rust
fn start_algorithm(
    block_tree: BlockTree,
    progress_message_sender: ProgressMessageSender,
    progress_message_receiver: ProgressMessageFilter,
    sync_request_sender: SyncRequestSender,
    sync_response_receiver: ,
) {

}

fn progress(
    block_tree: BlockTree,
    progress_message_sender: ProgressMessageSender,
    progress_message_receiver: ProgressMessageFilter,
) -> Result<(), ()> {
    
}

fn sync(
    block_tree: BlockTree,
    sync_request_sender: SyncRequestSender,
    sync_response_receiver: SyncResponseReceiver,
) {

}
```

### Pacemaker

```rust
trait Pacemaker {
    fn leader(validator_set: ValidatorSet, view: ViewNumber) -> PublicAddress;
    fn timeout(cur_view: ViewNumber, top_qc_view: ViewNumber) -> PublicAddress;
}
```

### Sync Server

```rust
fn start_sync_server(
    block_tree_snapshot_factory: BlockTreeSnapshotFactory,
    sync_request_receiver: SyncRequestReceiver,    
    sync_response_sender: SyncResponseSender,
) -> thread::JoinHandle<()> {

}
```

### Networking

```rust
trait Network {
    fn connect(peer: PublicAddr);
    fn disconnect(peer: PublicAddr);
    fn send(peer: PublicAddr, message: Message);
    fn recv() -> (PublicAddr, Message);
}
```

```rust
fn start_poller<N: Network>(network: N) -> Poller<N> {
    let (to_progress_msg_filter, progress_msg_from_poller) = mpsc::channel();
    let (to_sync_request_receiver, sync_request_from_poller) = mpsc::channel();
    let (to_sync_response_receiver, sync_response_from_poller) = mpsc::channel();

    let poller_thread = thread::spawn(move || {
        let (origin, msg) = network.recv();
        match msg {
            ProgressMessage(p_msg) => to_progress_msg_filter,
            SyncMessage(s_msg)
        }


        thread::yield_now();
    }) 
}

struct Poller {
    network: N,
    poller_thread: thread::JoinHandle<()>,
    progress_msgs_from_poller: Option<ProgressMessageFilter>,
    sync_requests_from_poller: Option<Receiver<(PublicAddr, SyncRequest)>>,
    sync_responses_from_poller: Option<Receiver<(PublicAddr, SyncResponse)>>,  
}

impl Poller {
    fn progress_message_filter(&self) -> ProgressMessageFilter; 
    fn sync_request_receiver(&self) -> SyncRequestReceiver;
    fn sync_response_receiver(&self) -> SyncResponseReceiver;
}
```


```rust
struct ProgressMessageFilter 

struct SyncResponseReceiver
```

// View State
let votes_received

if me == leader(v):
    if highest_qc.block has validator set changes:
        if highest_qc.phase == Prepare:
            broadcast Proposal::ExistingBlock { highest_qc, Vote { v, highest_qc.block, Precommit } }
        else if highest_qc.phase == Precommit:
            broadcast Proposal::ExistingBlock { highest_qc, Vote { v, highest_qc.block, Commit } }
        else: // highest_qc.phase == Generic or Commit
            let data, vs_changes = app.propose_block(highest_qc.block)
            let block = Block { data, highest_qc }
            if vs_changes == None:
                broadcast Proposal::NewBlock { block, Vote { v, highest_qc.block, Generic } }
            else:
                broadcast Proposal::NewBlock { block, Vote { v, highest_qc.block, Prepare } } 

if me != leader(v) block on receive proposal:
    if Proposal::NewBlock { block, vote } = proposal:

    else Proposal::ExistingBlock { justify, vote } = proposal:


                


### Algorithm real code

 